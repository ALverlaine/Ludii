// Scoring options

(define "GroupScore"
    (and
        (set Score Mover (max (sizes Group "ScoreConnection" Mover)))
        (set Score Next (max (sizes Group "ScoreConnection" Next)))
))

(define "BonusMover"
    (and
        (set Score Mover 
            (+ 
                (max (sizes Group "ScoreConnection" Mover))
                (count Groups "ScoreConnection" if:(= (who at:(to)) (mover))) 
        ))
        (set Score Next 
            (+ 
                (max (sizes Group "ScoreConnection" Next))
                (count Groups "ScoreConnection" if:(= (who at:(to)) (next))) 
))))

(define "BonusOpponent"
    (and
        (set Score Mover 
            (+ 
                (max (sizes Group "ScoreConnection" Mover))
                (count Groups "ScoreConnection" if:(= (who at:(to)) (next))) 
        ))
        (set Score Next 
            (+ 
                (max (sizes Group "ScoreConnection" Next))
                (count Groups "ScoreConnection" if:(= (who at:(to)) (mover))) 
))))

(define "OpponentGroupCount"
    (if 
        (!= 
            (count Groups "ScoreConnection" if:(= (who at:(to)) (next)))
            (count Groups "ScoreConnection" if:(= (who at:(to)) (mover))) 
        ) 
        (set Score Mover 
            (count Groups "ScoreConnection" if:(= (who at:(to)) (next)))
            (then
                (set Score Next 
                    (count Groups "ScoreConnection" if:(= (who at:(to)) (mover))) 
        )))
        // is difference an array different or a set difference i.e. unique elements?
        (set Score Mover 
           (- 0
           (max 0
               (max 
                   (difference 
                       (sizes Group "ScoreConnection" Mover) 
                       (sizes Group "ScoreConnection" Next)
           ))))
           (then
               (set Score Next 
                   (- 0
                   (max 0
                       (max 
                           (difference 
                               (sizes Group "ScoreConnection" Next) 
                               (sizes Group "ScoreConnection" Mover)
)))))))))

//----------------------------

(define "Anemone" 
    (or
        {
        (move Pass)
        (move Claim (to (sites Empty)))
        (forEach Site  // capture
            (sites To 
                (select 
                    (from 
                        (sites Occupied by:Next) 
                        if:(> 
                            (count Pieces Next in:(sites Around (from) "ConnectionDirection"))
                            (count Pieces Mover in:(sites Around (from) "ConnectionDirection"))
            ))))
            (move Remove (site)
                (then
                    (claim (to (last To)))
        )))
        }
        (then <SType:selScoring>)   
))

//-----------------------------------------------
// Main routine

(game "Windflowers"
    (players 2)
    (equipment
        {
        "BoardUsed"
        (piece "Ball" P1)
        (piece "Ball" P2)
        }
    )
    (rules
        (start 
            (set Score Each 0)
        )
        (play
            ("Anemone")
        )
        (end 
            (if 
                (all Passed)
                {
                (if 
                    (= (score Mover) (score Next))
                    (result Mover Loss) ///to prevent rotational symmetrical play on even boards
                )
                (if 
                    (!= (score Mover) (score Next))
                    (byScore)
                )
                }
))))

//-------------------------------------------------
// Defines for Options

(define "ScoreConnection" <BoardShape:directionScored>)
(define "ConnectionDirection" <BoardShape:directionUsed>)
(define "BoardUsed" <BoardShape:gridType> )

(define "HexLimp" (board (hex Limping (- <BoardSize:smallSide> 1)) use:Cell))
(define "Hex2Limp" (board (hex  (- <BoardSize:smallSide> 1) (+ <BoardSize:smallSide> 1)) use:Cell))
(define "HexCell" (board (hex Hexagon <BoardSize:smallSide>) use:Cell))
(define "TriSquare" (board (tiling T33434 (- <BoardSize:smallSide> 2)) use:Vertex))
(define "SquareGrid" (board (square <BoardSize:smallSide>) use:Cell))
(define "SquareDiagonal" (board (square (- (* 2 <BoardSize:smallSide>) 2)) use:Vertex))

//-----------------------------------------
// Options
// Notes: Opponent scoring on odd square diagonal grid leads to 1st player win by  diagonals only.

(option "Board Size" <BoardSize> args:{<smallSide> <backgroundSize>} 
    {
    (item "3 (20 moves)"  <3>  <1.30> "Order 3 board")
    (item "4 (60 moves)"  <4>  <1.20> "Order 4 board")*
    (item "5 (90 moves)"  <5>  <1.15> "Order 5 board")
    }
)

(option "Scoring" <SType> args:{<selScoring>}
    {
    (item "Most connected" <"OpponentGroupCount"> "Score a point for each opponent's group. Tie-breaker: Own the largest unpaired group.")*
    (item "Largest group" <"GroupScore"> "Score a point for each piece in your largest group - 10% fewer moves")

    }
)

(option "Board Grid" <BoardShape>
 args:{<gridType> <directionUsed> <diagShow> <directionScored> <backgroundImage>} 
 {
  (item "Hex Double Limping"
   <"Hex2Limp"> <Orthogonal> <Hidden> <Orthogonal> <"Disc">  
   "Hex N+1 / N-1 Grid")
   
  (item "TriSquare 7 direction majorities"
   <"TriSquare"> <All> <ThinDotted> <Adjacent> <"Disc"> 
   "Triangle-Square N-2 all directions connect paths to edge - Orthogonal only form groups, about 20% more moves")**
   
  (item "Square 8 direction majorities"
   <"SquareDiagonal"> <All> <ThinDotted> <Orthogonal> <"Square-alt1">
   "Square Grid 2N-2")

 }
)

//---------------------------------------------

(define "ColourBackground"  (colour 136 175 96)) //meadow (colour 146 175 86)) // tawny: (colour 175 146 86)) 

(metadata
    
    (info
        {
        (description "Windflowers is a finite, 2-player, place-or-capture, connectivity game. 
            It is playable on a wide variety of grid and connectivity types.
            
            Placement is to empty sites: Capture is by replacing an opponent's stone during placement if the opponent owns more of the surrounding stones. On boards with diagonals, diagonal connections are included in the count to determine if a piece can be captured, but are not used for determining scoring groups discussed below.
            
            Passing is allowed, and the game ends upon consecutive passes. The board typically is full at this point, but there might be capture options still available that are disadvantageous to take.
            
            Scoring is based on orthogonal connectivity: The player with the fewer groups of stones wins. Ties are broken in favor of the player who DOES NOT have the largest non-tied group. This adds sharpness to the play.
            If every thing is equal, the last to play wins. Thus on even boards, the first player is obligated to break mirror play to win.
            
            A variant scoring is: largest group. Tie breaker in this case is simply last to play.
            
        Of special interest is the way in which the threat of capture encourages early piece placement out-of-contact with one's own stones preventing large solid groupings of stones, and how it may be safely deferred until later when the capture may have more impact.  The actual number of captures in a game tend to be few and toward the end, and they play a disproportionate role in determining the winner."
        )
        (rules "Goal: Consolidate your own groups of stones, and divide your opponent's stones into as many different groups as possible.
            
            The board starts empty.
            Players take turns in alternation, starting with Dark. Passing is allowed. Consecutive passes end the game.
            
            On a turn either:
            1: Place a stone on an empty site, - or -
            2: Replace an opponent's stone with your own, provided that the opponent has more stones surrounding it than you do. On boards with diagonals, diagonaly adjacent stones are part of the count used to allow  or disallow capture.
            
            At the end of the game, score one point for each opponent's group. These scoring groups are determined orthogonally. In the case of a tie, group sizes are compaired, excluding the those all opponent-paired groups of the same size. Then the player with the largest group remaining LOSES. 
            
        A variant scoring option may be selected. In that case the largest group wins, and in case of a tie, last to place is the winner."
        )
        (version "1.2.8")
        (classification "experimental")
        (author "Dale W. Walton")
        (credit "Dale W. Walton")
        (date "8-09-2021")
        }
    )
    
    (graphics 
        {
        (player Colour P1 (colour 120 36 0))
        (player Colour P2 (colour Cream))
        (piece Scale "Ball" 0.92 )
        (piece Background "Ball" image:"Disc" fillColour:(colour 0 0 0 140) edgeColour:(colour 0 0 0 0)) 
        (board Colour Phase0 "ColourBackground")
        (board StyleThickness InnerEdges 0.4)
        (board StyleThickness OuterEdges 0.6)
        (board StyleThickness InnerVertices 0.45)
        (board StyleThickness OuterVertices 0.45)
        (board Colour InnerVertices (colour Grey))
        (board Colour OuterVertices (colour Grey))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
        (show Edges Diagonal <BoardShape:diagShow> (colour DarkGrey))
        
        (board Background image:<BoardShape:backgroundImage> fillColour:"ColourBackground" edgeColour:(colour 180 180 180 80)  scale:<BoardSize:backgroundSize>) 
        }
    )
)

