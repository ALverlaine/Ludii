// Scoring options

(define "GroupScore"
    (and
        (set Score Mover (max (sizes Group "ScoreConnection" Mover)))
        (set Score Next (max (sizes Group "ScoreConnection" Next)))
))

(define "BonusMover"
    (and
        (set Score Mover 
            (+ 
                (max (sizes Group "ScoreConnection" Mover))
                (count Groups "ScoreConnection" if:(= (who at:(to)) (mover))) 
        ))
        (set Score Next 
            (+ 
                (max (sizes Group "ScoreConnection" Next))
                (count Groups "ScoreConnection" if:(= (who at:(to)) (next))) 
))))

(define "BonusOpponent"
    (and
        (set Score Mover 
            (+ 
                (max (sizes Group "ScoreConnection" Mover))
                (count Groups "ScoreConnection" if:(= (who at:(to)) (next))) 
        ))
        (set Score Next 
            (+ 
                (max (sizes Group "ScoreConnection" Next))
                (count Groups "ScoreConnection" if:(= (who at:(to)) (mover))) 
))))

(define "OpponentGroupCount"
    (if 
        (!= 
            (count Groups "ScoreConnection" if:(= (who at:(to)) (next)))
            (count Groups "ScoreConnection" if:(= (who at:(to)) (mover))) 
        ) 
        (set Score Mover 
            (count Groups "ScoreConnection" if:(= (who at:(to)) (next)))
            (then
                (set Score Next 
                    (count Groups "ScoreConnection" if:(= (who at:(to)) (mover))) 
        )))
        // is difference an array different or a set difference i.e. unique elements?
        (set Score Mover 
           (- 0
           (max 0
               (max 
                   (difference 
                       (sizes Group "ScoreConnection" Mover) 
                       (sizes Group "ScoreConnection" Next)
           ))))
           (then
               (set Score Next 
                   (- 0
                   (max 0
                       (max 
                           (difference 
                               (sizes Group "ScoreConnection" Next) 
                               (sizes Group "ScoreConnection" Mover)
)))))))))

//----------------------------

(define "Anemone" 
    (or
        {
        (move Pass)
        (move Claim (to (sites Empty)))
        (forEach Site  // capture
            (sites To 
                (select 
                    (from 
                        (sites Occupied by:Next) 
                        if:(> 
                            (count Pieces Next in:(sites Around (from) "ConnectionDirection"))
                            (count Pieces Mover in:(sites Around (from) "ConnectionDirection"))
            ))))
            (move Remove (site)
                (then
                    (claim (to (last To)))
        )))
        }
        (then <SType:selScoring>)   
))

//-----------------------------------------------
// Main routine

(game "Windflowers"
    (players 2)
    (equipment
        {
        "BoardUsed"
        (piece "Ball" P1)
        (piece "Ball" P2)
        }
    )
    (rules
        (start 
            (set Score Each 0)
        )
        (play
            ("Anemone")
        )
        (end 
            (if 
                (all Passed)
                {
                (if 
                    (= (score Mover) (score Next))
                    (result Mover Loss) ///to prevent rotational symmetrical play on even boards
                )
                (if 
                    (!= (score Mover) (score Next))
                    (byScore)
                )
                }
))))

//-------------------------------------------------
// Defines for Options

(define "ScoreConnection" <BoardShape:directionScored>)
(define "ConnectionDirection" <BoardShape:directionUsed>)
(define "BoardUsed" <BoardShape:gridType> )

(define "HexLimp" (board (hex Limping (- <BoardSize:smallSide> 1)) use:Cell))
(define "Hex2Limp" (board (hex  (- <BoardSize:smallSide> 1) (+ <BoardSize:smallSide> 1)) use:Cell))
(define "HexCell" (board (hex Hexagon <BoardSize:smallSide>) use:Cell))
(define "TriSquare" (board (tiling T33434 (- <BoardSize:smallSide> 2)) use:Vertex))
(define "SquareGrid" (board (square <BoardSize:smallSide>) use:Cell))
(define "SquareDiagonal" (board (square (- (* 2 <BoardSize:smallSide>) 2)) use:Vertex))

//-----------------------------------------
// Options
// Notes: Opponent scoring on odd square diagonal grid leads to 1st player win by  diagonals only.

(option "Board Size" <BoardSize> args:{<smallSide> <backgroundSize>} 
    {
    (item "3 (20 moves)"  <3>  <1.30> "Order 3 board")
    (item "4 (60 moves)"  <4>  <1.20> "Order 4 board")*
    (item "5 (90 moves)"  <5>  <1.15> "Order 5 board")
    }
)

(option "Scoring" <SType> args:{<selScoring>}
    {
    (item "Most connected" <"OpponentGroupCount"> "Score a point for each opponent's group. Tie-breaker: Own the largest unpaired group.")*
    (item "Largest group" <"GroupScore"> "Score a point for each piece in your largest group - 10% fewer moves")

    }
)

(option "Board Grid" <BoardShape>
 args:{<gridType> <directionUsed> <diagShow> <directionScored> <backgroundImage>} 
 {
  (item "Hex Double Limping"
   <"Hex2Limp"> <Orthogonal> <Hidden> <Orthogonal> <"Disc">  
   "Hex N+1 / N-1 Grid")
   
  (item "TriSquare 7 direction majorities"
   <"TriSquare"> <All> <ThinDotted> <Adjacent> <"Disc"> 
   "Triangle-Square N-2 all directions connect paths to edge - Orthogonal only form groups, about 20% more moves")**
   
  (item "Square 8 direction majorities"
   <"SquareDiagonal"> <All> <ThinDotted> <Orthogonal> <"Square-alt1">
   "Square Grid 2N-2")

 }
)

//---------------------------------------------

(define "ColourBackground"  (colour 136 175 96)) //meadow (colour 146 175 86)) // tawny: (colour 175 146 86)) 

(metadata
    
    (info
        {
        (rules "Goal: Consolidate your own groups of stones, and divide your opponent's stones into as many different groups as possible.
            
            The board starts empty.
            Players take turns in alternation, starting with Dark. Passing is allowed. Consecutive passes end the game.
            
            On a turn either:
            1: Place a stone on an empty site, - or -
            2: Replace an opponent's stone with your own, provided that the opponent has more stones surrounding it than you do. On boards with diagonals, diagonaly adjacent stones are part of the count used to allow  or disallow capture.
            
            At the end of the game, score one point for each opponent's group. These scoring groups are determined orthogonally. In the case of a tie, group sizes are compaired, excluding the those all opponent-paired groups of the same size. Then the player with the largest group remaining LOSES. 
            
        A variant scoring option may be selected. In that case the largest group wins, and in case of a tie, last to place is the winner."
        )
        }
    )
    
    (graphics 
        {
        (player Colour P1 (colour 120 36 0))
        (player Colour P2 (colour Cream))
        (piece Scale "Ball" 0.92 )
        (piece Background "Ball" image:"Disc" fillColour:(colour 0 0 0 140) edgeColour:(colour 0 0 0 0)) 
        (board Colour Phase0 "ColourBackground")
        (board StyleThickness InnerEdges 0.4)
        (board StyleThickness OuterEdges 0.6)
        (board StyleThickness InnerVertices 0.45)
        (board StyleThickness OuterVertices 0.45)
        (board Colour InnerVertices (colour Grey))
        (board Colour OuterVertices (colour Grey))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
        (show Edges Diagonal <BoardShape:diagShow> (colour DarkGrey))
        
        (board Background image:<BoardShape:backgroundImage> fillColour:"ColourBackground" edgeColour:(colour 180 180 180 80)  scale:<BoardSize:backgroundSize>) 
        }
    )
)

