// Standard defines "StepToEnemy" "StepToEmpty" "IsInCheck" "SameTurn"
// Note:"IsInCheck" parameter #3 is used with moves instead of location 

// *** Pieces

(define "Diagonals"
 (sites To (slide (from #1) Diagonal #2))
)

(define "ElbowSites"   // #1 (from int)  #2 (is Empty (to)) or (not (is Mover (who at:(to))))
 (sites 
  (results
   from:#1
   to:(sites
    (results
     from:(sites Incident Cell of:Vertex at:(from))
     to:(forEach
      (sites Incident Vertex of:Cell at:(from))
      if:#2
     )
     (to)
   ))
   (to)
)
  )
 )
   
(define "NodalQueen"
 (piece #1 Each 
  (move
   (from (from))
   (to
    (union {
      ("Diagonals" (from) (to if:("IsEnemyAt" (to))))
      ("ElbowSites" 
       (union
        ("Diagonals" (from) ~ ) //(to if:(is In (to) (sites Empty)))) Explicitly adding this causes bug
        (sites {(from)})
       )
       (not (is Mover (who at:(site))))
      )
      (forEach 
       of:("ElbowSites" 
        (union
         ("Diagonals" (from) ~) //(to if:(is In (to) (sites Empty)))) Explicitly adding this causes bug
         (sites {(from)})
        )
        (is Empty (site))
       )
       ("Diagonals" (site) (to if:("IsEnemyAt" (to))))
      )
    })
    (apply 
     (if ("IsEnemyAt" (to)) 
      (remove 
       (to) 
       #2
      )
      (set NextPlayer (player (next)))  // dummy action to allow move without capture.
   )
     )
    )
   #3
)
  )
 )

(define "NodalBishop"
 (piece #1 Each 
  (move
   Slide All
   (to 
    if:("IsEnemyAt" (to)) 
    (apply 
     (if ("IsEnemyAt" (to)) 
      (remove 
       (to) 
       #2
   )
      )
     )
    )
   #3
)
  )
 )


(define "NodalKnight"
 (piece #1 Each 
  (move Leap 
   { {F R F F} {F L F F} }
   (to 
    if:(not (is Mover (who at:(to))))
    (apply
     (if (is Next (who at:(to)))
      (remove
       (to)
       #2
      )
      (if 
       (< 0
        (count Pieces Next
         in:(intersection
          (sites Around (to) All) 
          (sites Around (from) All)
       )))
       (remove
        (intersection
         (sites Around (to) All) 
         (sites Around (from) All)
        )
        #2
   )
       )
      )
     )
    )
   #3
)
  )
 )

(define "CheckWorkAroundForKnight"  
 //Moves to attack the removal location piece when it is possible for a Knight to remove a piece by jumping.
 (forEach Piece "Knight"
  (or
   (move Step Diagonal
    (to 
     if:(and
      ("IsEnemyAt" (to)) 
      (< 0
       (count Sites
        in:(difference  // the potential end location of the Knight's actual move
         (sites Around (to) Orthogonal if:(is Empty (to)))
         (sites Around (from) Orthogonal)
     )
        )
       )
      )
     (apply (remove (to)))
   ))  
   (move Step 
    Orthogonal
    (to 
     if:(and
      ("IsEnemyAt" (to)) 
      (< 0
       (count Sites
        in:(difference  // the potential end location of the Knight's actual move
         (sites Around (to) Diagonal if:(is Empty (to)))
         (sites Around (from) Orthogonal)
     )
        )
       )
      )
     (apply (remove (to)))
)
    )
   )
  )
 ) 

(define "NodalPawn"
    (piece #1 Each 
        (or { // Forwards has bug
            (move Step (if (= 1 (mover)) (union N (union NE NW)) (union S (union SW SE))) (to if:(is Empty (to))) #2)
            ("StepToEnemy" Diagonal #2)
            }
//            #3
        )
    )
)

(define "NodalKingStep"
 (move
  Step All 
  (to
   if:(and
    {
     (!= #2 (to))
     #1 
     (not
      (is In (to)
       (sites #2 { { F F } {F F R F F}})
     ))
    }
   )
   (apply
    if:("IsEnemyAt" (to))
    (remove 
     (to)
  )
    )
   )
  #3
)
 )

(define "DoubleSteps" { {F R F F} {F L F F} {F R F} } )

(define "KingDoubleStep"  // for threats and capturing source of Check
 (move
  (from (from))
  (to
   (difference (sites (from) "DoubleSteps") (sites Around (from) All))
   if:(and
    {
     #1 //(is Next (who at:(to)))
     (< 0
      (count Sites
       in:(intersection
        (sites Around (from) All if:(is Empty (to))) 
        (sites Around (to) All)
     )))
    }
   )
   (apply 
    (if
     ("IsEnemyAt" (to))
     (remove 
      (to)
      #2
)
     )
    )
   )
  )
 )

(define "NewTurn" (not ("SameTurn")))

(define "NodalKing"
 // moves 2 but not straight
 // can only move through check to capture the source of the check
 // may capture along the way, but not if in check when capturing.
 // Can check another King through Check
 (piece #1 Each 
  (if
   ("NewTurn")
   (or {     
     ("NodalKingStep" ("IsEnemyAt" (to)) (from) (then (moveAgain #2))) 
     ("NodalKingStep" (is Empty (to)) (from) (then (moveAgain #2)))
     ("KingDoubleStep" ("IsEnemyAt" (to)) ~)
     ("KingDoubleStep" (is Empty (to)) ~)
    }
    (then (set Var "LF" (last From)))
   )
   (or {
     (move Pass)    
     ("NodalKingStep" ("IsEnemyAt" (to)) (var "LF") ~) 
     ("NodalKingStep" (is Empty (to)) (var "LF") ~)
    })
   )
  )
 )

(define "DidNotCrossStillExistingCheck"
 (can Move
  (do
   (move Step 
    (from (last To))
    All
    (to // Site moved through -- or else homesite if it is adjacent.
     if:(is In (to) (sites Around (var "LF") All includeSelf:True))
   )
    )
   ifAfterwards:(or
    (not ("IsInCheck" "King" Mover (forEach Piece  {"Queen" "Knight" "Bishop" "Pawn"} )))
    (= (var "LF") (last To))  //Moving back to the original position means the move is allowed because it was to an adjacent site.
)
   )
  )
 )

(define "KingNotCheckedAndToEmpty"
 (and 
  (is Empty (to)) 
  (not ("IsInCheck" "King" Mover at:(to)))
 ) 
)

//------------------------------------------------------------------------------

(game "Nodal Chess" 
 (players {(player N) (player S)}) 
 (equipment { 
   (board
    (add
     (remove
      (rectangle 8 6) 
      cells:{1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33}
     )
     edges:{ { 1 2 }{ 3 4 }{ 6 12}{11 17}{18 24}{23 29} {30 36}{35 41}{43 44}{45 46} }
    ) 
    use:Vertex
   ) 
   
   ("NodalPawn" "Pawn"
    (then
     (and
      (if
       (is In (last To) (sites Mover "Promotion")) 
       (moveAgain)
      )
      (set Counter)
     )
    )
   )
   ("NodalKing" "King" (then (set Counter)))
   ("NodalBishop" "Bishop" (then (set Counter)))
   ("NodalKnight" "Knight" (then (set Counter)))
   ("NodalQueen" "Queen" (then (set Counter)))
   (regions "Promotion" P1 (sites Top))
   (regions "Promotion" P2 (sites Bottom))
  })
 
 (rules 
  (start { 
   (place "Pawn1" (sites Row 1))
   (place "Pawn2" (sites Row 6))
   (place "Knight1" {"B1" "E1"}) 
   (place "Bishop1" {"A1" "F1"}) 
   (place "Queen1" coord:"C1") 
   (place "King1" coord:"D1" state:1) 
   (place "Knight2" {"B8" "E8"}) 
   (place "Bishop2" {"A8" "F8"}) 
   (place "Queen2" coord:"C8") 
   (place "King2" coord:"D8" state:1) 
  })
  
  (play 
   (if "NewTurn"
    (or
     (do 
      (forEach Piece {"Queen" "Knight" "Bishop" "Pawn"} )
      ifAfterwards:(and
       {
        (not ("IsInCheck" "King" Mover ~)) 
        (not ("IsInCheck" "King" Mover ("CheckWorkAroundForKnight")))
       }
     )
      )
     (do 
      (forEach Piece  "King")
      ifAfterwards:(and {
        (not ("IsInCheck" "King" Mover ~)) 
        (not ("IsInCheck" "King" Mover ("CheckWorkAroundForKnight")))
        ("DidNotCrossStillExistingCheck")
       })
      )
     )
    
    // 2nd parts of moves (for Pawn promotion and King moves)
    (if ("IsPieceAt" "King" Mover (last To))
     (do 
      (forEach Piece "King" Mover) 
      ifAfterwards:(and
       {
        (not ("IsInCheck" "King" Mover ~)) 
        (not ("IsInCheck" "King" Mover ("CheckWorkAroundForKnight")))
       }
     ))
     (move Promote (last To) (piece {"Queen" "Knight" "Bishop"}) Mover)
    )
    
  )
   )  
  (end {
   (if (no Moves Next) (result Mover Win)) 
   (if (= (counter) 99) (result Mover Draw)) 
  })
 )
)

//------------------------------------------------------------------------------

(metadata 
 
 (info
  {

  })
 
 (graphics {
  (show Check "King")
  (piece Scale "Pawn" 0.825)
  (piece Families {"Defined" "Microsoft" "Pragmata" "Symbola"})
  (board Style Chess)
  (board StyleThickness InnerEdges .3)
  (board StyleThickness OuterEdges .3)
//  (show Edges All Diagonal Hidden)
  (board StyleThickness InnerVertices .4)
  (board StyleThickness OuterVertices .4)
  (board Colour Phase0 (colour LightTan))
  (board Colour InnerEdges (colour Grey))
  (board Colour OuterEdges (colour Grey))
  (board Colour InnerVertices (colour Grey))
  (board Colour OuterVertices (colour Grey))
 })
 
 (ai 
  (bestAgent "Alpha-Beta")
  (heuristics
   {
    (material
     transformation:(divNumInitPlacement)
     pieceWeights:{
      (pair "Pawn1" 1.0)
      (pair "Pawn2" 1.0)
      (pair "Bishop1" 6.0)
      (pair "Bishop2" 6.0)
      (pair "Knight1" 3.0)
      (pair "Knight2" 3.0)
      (pair "Queen1" 4.0)
      (pair "Queen2" 4.0)
     }
    )
   }
  )
 )
)

